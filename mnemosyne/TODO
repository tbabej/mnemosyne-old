Big server:
         10676105 function calls (10675974 primitive calls) in 65.932 CPU seconds

   Ordered by: cumulative time
   List reduced from 505 to 150 due to restriction <150>

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000   66.072   66.072 benchmark_sync.py:102(sync)
        1    0.000    0.000   65.370   65.370 benchmark_sync.py:98(do_sync)
        1    0.000    0.000   64.160   64.160 client.py:42(sync)           
        1    1.684    1.684   63.387   63.387 client.py:179(get_server_log_entries)
   264744    2.808    0.000   40.793    0.000 SQLite_sync.py:284(apply_log_entry)  
   320589   26.483    0.000   26.483    0.000 {method 'execute' of 'sqlite3.Connection' objects}
   224969    2.414    0.000   25.376    0.000 SQLite_sync.py:267(apply_repetition)              
   224969    0.729    0.000   21.615    0.000 database_logger.py:84(repetition)                 
   224969    0.828    0.000   20.226    0.000 SQLite_logging.py:114(log_repetition)             
   264744    8.859    0.000   15.182    0.000 synchroniser.py:76(XML_to_log_entry)              
   264790    1.581    0.000    6.406    0.000 socket.py:375(readline)                           
   264745    0.746    0.000    6.223    0.000 <string>:83(XML)                                  
   264745    4.040    0.000    4.040    0.000 {built-in method feed}                            
     6661    2.924    0.000    2.924    0.000 {method 'recv' of '_socket.socket' objects}   

Big client:
Wed Feb 10 10:49:28 2010    mnemosyne_profile.sync

         3606012 function calls (3605956 primitive calls) in 78.224 CPU seconds

   Ordered by: cumulative time
   List reduced from 495 to 20 due to restriction <20>

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000   78.240   78.240 benchmark_sync.py:102(sync)
        1    0.000    0.000   77.516   77.516 benchmark_sync.py:98(do_sync)
        1    0.000    0.000   77.492   77.492 client.py:42(sync)
        1    2.016    2.016   58.574   58.574 client.py:130(put_client_log_entries)
   265647   32.239    0.000   38.501    0.000 SQLite_sync.py:158(<genexpr>)
       11    0.000    0.000   16.825    1.530 httplib.py:940(getresponse)
       11    0.000    0.000   16.825    1.530 httplib.py:384(begin)
       60    0.002    0.000   16.823    0.280 socket.py:375(readline)
     1353   16.821    0.012   16.821    0.012 {method 'recv' of '_socket.socket' objects}
       11    0.000    0.000   16.820    1.529 httplib.py:347(_read_status)
        9    0.000    0.000   16.784    1.865 urllib2.py:120(urlopen)
        9    0.000    0.000   16.783    1.865 urllib2.py:371(open)
        9    0.000    0.000   16.781    1.865 urllib2.py:399(_open)
       18    0.000    0.000   16.781    0.932 urllib2.py:359(_call_chain)
        9    0.000    0.000   16.781    1.865 urllib2.py:1145(http_open)
        9    0.000    0.000   16.781    1.865 urllib2.py:1085(do_open)
        1    0.000    0.000   16.765   16.765 client.py:203(finish_request)
   265646   10.300    0.000   10.990    0.000 synchroniser.py:53(log_entry_to_XML)
   265646    3.427    0.000    6.261    0.000 SQLite_sync.py:69(_log_entry)
   265660    0.931    0.000    6.227    0.000 httplib.py:719(send)


-make all logging go through logger interface
-make more use of Bunch in deleted_ events

-cards truncate easiness?

-rename media files-> external files?

-remove \n hack, streaming XML decompression

-add q and a to cards if facts are not present
-cdata, encode for deck name, unicode + test
-test scheduled, active count sync on load/save + type
-check if get_log_entries_to_sync_for really returns iterator
-create new database on server side if needed
-self.stopped, timeouts
-synchroniser --> xml formatter?
-more elegant error handling?
-add modulo to progress dialogs
-more code sharing between client and server?
-add streaming connection to server side too
-\r client /n vs server?
-don't have separate connection to get number of entries
-exchange card types between different SRS, add support for card type events
-http://live.gnome.org/Tomboy/Synchronization/REST
-same connection throughout?
-sql roll back?
-conflict resolution
-benchmarks
-think about sending across cards as pictures
-test where buffering makes a difference
-linebreak in fact data upsetting get history
-multiuser server, token?
-ui: pass or notImplemented?
-time saxutils.escape attr
-server can report can refuse large files
-streaming compression
http://www.linuxtopia.org/online_books/programming_books/python_programming/python_ch33s08.html
http://www.dev-explorer.com/articles/using-python-httplib
-activating cards
-make sure to convert int(time.time()) to integer
-make sure all events make it to the sync protocol + formats
-how to prevent different instantiations from uploading logs twice
-mechanism to have plugin settings synced?
-pull in user id on first sync
-wsgi streaming send for media tar archive (mmap?)
-hack tarfile to add progress bar?
-add tests with unicode in basedir
-just copy database on initial sync
-make sure after import all sync events fire
-create openSM2sync.database interface. Add comment on mediadir relative, / vs \ in filenames
-chunk reading history events in larger blocks?
-update readme. Mention how clients should deal with update events of cards that were deleted
 later on. Mention that only final state is same, not intermediate states
-example 'miniclient' supporting sync
-log save event after import and sync in the default controller. Add tests

I looked further into it, using BaseHTTPServer.

- the output stream of the server was unbuffered by default. buffering
it saves a bit of time, eg

        wfile = self.connection.makefile("wb", 4096)
        for chunk in generate_JSON(cards):
            wfile.write(chunk)

- looking at the source code of httplib (which urllib uses), it also
uses an unbuffered file by default. performance nearly as good as the
tcp server can be achieved by fetching the data in one go using
urlretrieve() and then iterating over the retrieved file, and the same
performance as the socket implementation can be achieved by using a
buffered file instead:

def parse_JSON(fileobj):
   import simplejson, time
   fp = os.fdopen(fileobj.fileno(), 'rb', -1)
   for data in fp:
      simplejson.loads(data) 


-current active set not marked upon entering
-get_activity_criterion also returns default criterion. Make sure it is not used to construct the criteria list in the GUI

-empty tags
-convert default tags on import
-test case for hierarchy parsing ["a", "bye bye", "a::b", "a::c", "b::c::d"]:
-add update after import
-sync adding sets

-where to move txt_log_parser
-need component.statisticspages and configuration widgets?

-move ~/.mnemosyne to .config/mnemosyne as per freedesktop standard?
https://bugzilla.gnome.org/show_bug.cgi?id=518585

-post nose 0.11: add cover branches


-duplicates for fact speedup
>         """Return fact with the same 'unique_fields' data as 'fact'."""
>         
>         query = "select _id from facts where card_type_id=?"
>         args = (fact.card_type.id,)
>         if fact._id:
>             query += " and not _id=?"
>             args = (fact.card_type.id, fact._id)
>         duplicates = []            
>         for cursor in self.con.execute(query, args):
>             data = dict([(cursor2["key"], cursor2["value"]) for cursor2 in \
>                 self.con.execute("""select * from data_for_fact where
>                 _fact_id=?""", (cursor[0], ))])
>             for field in fact.card_type.unique_fields:
>                 if data[field] == fact[field]:
>                     duplicates.append(\
>                         self.get_fact(cursor[0], id_is_internal=True))
>                     break
>         return duplicates

-rework interface of database.py to include syncing events.


-id vs _id
-tag.id in criteria?
-is it worth keeping database.tag_names?
-get rid of 'get_'

-number of unmemorised cards to hold in your hand? (i.e. grade 0 + 1)
-rework give initial grade dialog

-time WM: history in same DB?

-rework progress bar API

-more tests
-update_cards --> modify cards?

-windows: upgrade config?
-windows: HOME
-test unicode filenames in sync protocol


-card browser
-make sure searching for a single unicode character works
-qsortfilter proxy
-show number of cards selected
-card.in_view needed?
-make card browser remember its size

-do better numeric sort on card browser and activate cards


-implement duplicate checking
-confirmation dialog for deleted cards
-explain check for duplicates after import of 1.x? Also give a hint of its working in
the GUI function itself?
-card preview
-MVC: http://doc.trolltech.com/qq/qq24-delegates.html


-don't auto vacuum? what for WM?
-more fine grained resource_limited

-delete 1.99 logs
-reenable upload

-... after menu options that open a dialog
-suppress autorepeat on review dialog

-do review_controller.rebuild_queue, reload counter after edit deck, clean duplicates

-new translation infrastructure
-handle deferred translation
-different translators for different users?

-import
-update data if same id present on import
-on import, activate plugins, created card types if necessary
-on import don't add cards for which card type is not present
-warn when not importing a duplicate card
-xml import tests (wcu, memaid, plconv)
-rewrite test_mem_import test_sch to go through the controller
-option to detect and mark inverses on import?
-update XML import/export to new database format
-warn when importing card type with duplicate id
-option to add tags on import
-save import dir
-make sure enter does not close the import dialog
-make sure we log new card creation on import
-make sure to detect media and do slash normalisation from importing text files
-'teacher mode' on export, which allows pupils to update previously imported
 cards, as opposed to adding new cards. Implemented through id's of the form
 T.<fixed card id for all pupils>.<pupil user id>?
-when resetting learning data on export, can we export facts only? Tags are on
 a per card basis.
-utf16?
-make sure all grades are shown on first revision of imported card. Adapt button group title
-http://gitorious.org/hooq/hooq? Qt4 testing
 http://www.fredemmott.co.uk/blog/2010/01/18/Qt4%20GUI%20Testing%20with%20Hooq

-tips (both on startup and on use): right click to add cards or sound, comma to 
 separate tag names, :: to separate hierarchies
-comment/tip about not having to do all your scheduled repetitions in
 one sitting
-upgrade docs on duplicate checking
-update tooltips, inform Patrick
-tar file size estimate sometimes off by one record.

http://pysnippet.blogspot.com/2010/02/qtabwidget-hiding-bar.html
-have hierarchy in plugin names

-test uploading of logs, also in rollover

-better mechanism to have different renderers

-see if graphical glitch is fixed with latest matplotlib version, reenable
 remember size

-make distrib

-http://www.mblondel.org/journal/2008/08/01/web-canvas/

-check for related cards on same day could fail if minute level scheduler is used in the meantime
 (update comment in scheduler too)

-infrastructure to make it easier to type certain symbols

-mark cards plugin

-ampersand mnemonics everywhere

-partial implementation of type answer (none/all/special tag? Db Attribute? Button?)
-draw answer, make configurable by card type

-more plugin examples: file format, custom tag, activate all cards,
 last grade filter

-leech detection (mod 15)

-ask people about biggest gripe in Mnemosyne, things that did not behave as expected


-copy card and create a new one that way

-also add option to download source in the info box

-explain license on our website

-grep through TODO's in source code

-alt tabbing gives low res icon.

-modality of dialogs (mail by Nosai), Qt.WStyle_MinMax | Qt.WStyle_SysMenu))?

-allow edit current card and add card to be open at the same time?

-make file handling more robust, detect all errors (see mail by
 OldGrantonian)

-reenable datadir in setup.py

-make filters more efficients by using regex instead of loops.

-easier function to do tag detection in plugin

-bug in Qt: setting default colour to black does not register the colour clicks.

-document cntrl enter in edit dialog instead of clicking ok

pylint:
	find ./mnemosyne/libmnemosyne/ -name \*.py | while read f ; do echo $f;pylint $f 2>&1|grep ^E:; done

-Contributors: Konrad Wojas, Laurent Mauron, Ed Bartosh, Mike Appleby, Max Usachev

-Faq about how to pronounce Mnemosyne

-delete key shortcut for saved sets


* After 2.0:

-website redesign? like http://hanzim.com/download.php

-add days since last rep / until next rep to statistics

-don't activate plugins until after clicking ok

-respect font in fact editor

-card type with prefilled fields

-update ohloh?

-skritter/cpod interop mail

-better supermemo import

-get rid of mp3 clip prevention?

-plugin to store backups on dropbox

-detect wrong current date (last review in the future or way past)

-improve sphinxdocs: autoclass='both', document module members

-show latex errors in GUI?

-add media to a card but then abandonig/editing the card keeps the media in media directory
 (they are not referenced in the database, though)

-pythoscope? http://pypi.python.org/pypi/pythoscope/0.2.1
http://pythoscope.org/
-pyflakes?

-hover over extra hanzi information, hanzi statistics

-plugin for midi files

-chinese pod plugin

-"reschedule" cheating plugin

-improve learn ahead, by learing ahead per day and prioritising within each day


Windows Mobile client:

If your phone has a touchscreen use the pocket pc version. Otherwise try the smartphone version. 

-better way of making default actions visible? Call layout()?
-hook up scheduler rollover
-cramming widget, cache counters
-implement hide question
-icon
-more complete question box implementation
-installer
-set basedir in registry key
-install only pyc files
-mark card
-play around with MW5torage for easier sync and document this if it works.
-button color

Multiuser statistics analysis:

-break out card id stringss to a different table and use interger _id in the rest of
 the database to save space
-move times from a later start date to save space?
-investigate origin of ._ logs
-don't do card checks for post 2.0

-download media files when giving URL

-three sided export?

-synonym handling plugin?

-regular expression search?

-add 'add card' option to deck manager?

-active alert as plugin

-zooming picture instead of scrollbars?
 
-animated strokes: http://lost-theory.org/ocrat/

-congratulations screen

-language text based card types, with 'graduating' from word cards once they are learned enough,
 and only keeping sentence cards (mail by querido, scheduler feedback needed)

-scheduler with minute granularity?

-widget to create new card types. Makes sure the criteria updating code gets called.


* Miscellaneous:

-change file suffix when changing export format

-button after opening fact editor in edit deck to go to next card in the list

-sound recorder

-store _fact_ids_learned in config, such that they persist over sessions?

-auto identifying similar cards

-unify number shortcuts (with and without Ctrl)

-forward / backward when previewing cards in the database

-clean up interval when importing from txt

-paste from clipboard

-font and color comboboxes instead of dialogs in card appearance?

-preselect all in some text fields, so that the users can start typing
 immediately

-feedback about uploads in GUI / add time-out

-drag and drop of pictures, sound files

-autoupgrade, or at least notify of available upgrade (needs a separate thread)

-bundle docs

-undo last grade + keyboard shortcut. Disable undo after logs have been purged

-http://labs.trolltech.com/blogs/2009/03/12/wysiwyg-html-editor/

-integrate Mnemosyne analysis, advanced statistics, history,
 forgetting index, histogram of grades and intervals... (look at graphs
 in JMemorize)

-importing cards from rss feed

-clean obsolete latex images / autogenerate them

-investigate ridiculously large thinking times

-determine import / export file type based on suffix
 (i.e. remove file format field)? Probably not possible, as
 file dialogs only return filenames, not the chosen filter type.

-swac plugin, smart.fm

-corner case: If M > 0 and k < 0 then (a,b) is a local maximum
If M > 0 and k > 0 then (a,b) is a local minimum: eats < ... >

