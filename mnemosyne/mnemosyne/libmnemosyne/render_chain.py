#
# render_chain.py <Peter.Bienstman@UGent.be>
#

from mnemosyne.libmnemosyne.component import Component


class RenderChain(Component):

    """A RenderChain details the operations needed to get from the raw data
    in a card to a representation of its question and answer, in a form either
    suitable for displaying in a browser, or exporting to a text file, ... .

    First the raw data is sent through Filters, which perform operations
    independent of card type, like expanding relative paths.

    Then this data is assembled in the right order in a Renderer, which can
    be card type specific.

    Plugins can add Filters or Renderers for a new card type to a chain at
    run time.

    """

    component_type = "render_chain"
    id = "default"

    filters = []
    renderers = []

    def register_filter(self, filter):
        self.filters.append(filter)

    def register_renderer(self, renderer):
        self.renderers.append(renderer)

    def render_question(self, card, **render_args):
        data = card.card_type.fact_data(card)
        fields = card.fact_view.q_fields
        # Run filters. Note that the filters run only on the data, not on the
        # full content generated by the renderer, which would be much slower.
        for field in fields:
            for f in self.filters(render_chain):
                data[field] = f.run(value, **render_args)
        # Asseble in renderer.
        renderer = None # renderer for card type? If not, general
        return renderer.render_fields(data, field, card.card_type, **render_args):

    def render_answer(self, card, **render_args):
        pass

