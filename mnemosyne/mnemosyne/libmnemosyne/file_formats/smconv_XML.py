#
#  smconv_XML.py <Felix.Engel@fcenet.de>, <Peter.Bienstman@UGent.be>
#

import os
import math
import time
from xml.etree import cElementTree

from mnemosyne.libmnemosyne.translator import _
from mnemosyne.libmnemosyne.file_format import FileFormat
from mnemosyne.libmnemosyne.file_formats.media_preprocessor \
    import MediaPreprocessor


class Smconv_XML(FileFormat, MediaPreprocessor):

    """Import the xml file created by the smconv.pl script to Mnemosyne.
    smconv.pl is available at http://smconvpl.sourceforge.net and reads
    SuperMemo for Palm databases and exports them to XML.

    In order to import the generated XML into mnemosyne, care must be taken
    to ensure the correct charset encoding of the input file. In my case,
    the palm databases are "windows-1252". The xml file generated by smconv.pl
    was set to "us-ascii". This makes the XML parser fail. For me, changing
    the xml header to <?xml version="1.0" encoding="windows-1252"?>  worked
    well. However, your mileage may vary.

    Restrictions:

    - SM for Palm has six fields for each card. Templates can be used to
      format these fields and to control whether they are part of  the
      question or of the answer. However this class assumes that the first
      field is the question and the second field is the answer.

    """

    description = _("Supermemo for Palm through smconv.pl")
    extension = ".xml"
    filename_filter = _("Supermemo for Palm XML files (*.xml *.XML)")
    import_possible = True
    export_possible = False

    def do_import(self, filename, extra_tag_names=None):
        FileFormat.do_import(self, filename, extra_tag_names)
        w = self.main_widget()
        try:
            tree = cElementTree.parse(filename)
        except cElementTree.ParseError, e:
            w.show_error(_("Unable to parse file:") + str(e))
            return
        # Todo: remove
        filedatecommit = tree.find("header").attrib["datecommit"]
        try:
            struct_t = time.strptime(filedatecommit, "%Y-%m-%d")
            t_sec = time.mktime(struct_t)
            import_time_of_start = StartTime(t_sec);
        except:
            import_time_of_start = StartTime(0);
        self.items = []
        for element in tree.find("cards").findall("card"):
            category = card.attrib["category"]
            commit = not (card.attrib["commit"] == "0")
            for field in card.find("card_fields").findall("card_field"):
                if field.attrib["idx"] == "1":
                    question = field.text
                else:
                    answer = field.text
            card_other = card.find("card_other")
            datecommit = card_other.attrib["datecommit"]
            datecreate = card_other.attrib["datecreate"]
            datenexttest = card_other.attrib["datenexttest"]
            difficulty = int(card_other.attrib["difficulty"]) #  Default: 40.
            difficulty_prev = int(card_other.attrib["difficulty_prev"])
            interval = int(card_other.attrib["interval"])
            interval_prev = int(card_other.attrib["interval_prev"])
            lapses = int(card_other.attrib["lapses"])
            recalls = int(card_other.attrib["recalls"])
            # Try to derive an easines factor EF from [1.3 .. 3.2] from
            # difficulty d from [1% .. 100%].
            # The math below is set to translate
            # difficulty=100% --> easiness = 1.3
            # difficulty=40% --> easiness = 2.5
            # difficulty=1% --> easiness = 3.2
            dp = difficulty * 0.01
            # Small values should be easy, large ones hard.
            if dp > 0.4:
                easiness = 1.28 - 1.32 * math.log(dp)
            else:
                easiness = 4.2 - (1.139 * math.exp(dp))
            # Grades are 0-5. In SM for Palm there are commited and uncommited
            # cards. Uncommited cards go to grade -1.
            # Otherwise try to extrapolate something from difficulty in SM
            # I have implemented guess_grade such, that the distribution of
            # grades looks reasonable for my test database of 4000 entries.
            # By "reasonable" I mean than most of the entries should be
            # at grade 4. I've been learning that database for 4 years, so the
            # cards should have converged by now.
            if commit == False:
                grade = -1
            # Very easy items are scarce in SM and must be easiest grade.
            elif difficulty < 10:
                grade = 5
            # Assign passing grades, based upon whether the difficulty has
            # changed.
            elif difficulty > difficulty_prev:
                grade = 2
            elif difficulty == difficulty_prev:
                grade = 3
            elif difficulty < difficulty_prev:
                grade = 4
            # If the interval becomes shorter, it must have been a failure.
            if interval < interval_prev:
                grade = 0
            # Handle dates, assume starttime to be the epoch.
            # Need to determine last_rep and next_rep.
            try:
                struct_t = time.strptime(self.datenexttest,"%Y-%m-%d")
            except:
                print "Failed to parse time - using zero."
            t_sec = int(0)
            try:
                t_sec = time.mktime(struct_t)
            except:
                print "mktime failed - using zero."
            next_rep = int(t_sec / 86400)
            # last_rep is interval in days before next_rep.
            last_rep = next_rep - interval
            # Try to fill acquisiton reps and retention reps.
            # Since SM statistics are only available for commited
            # cards, I take acq_reps = 0 and ret_reps = lapses + recalls.
            ret_reps = lapses + recalls
            # During the import, there was no guarantee that the start time
            # has already been read. Now, at the smconv_pl closing tag, the
            # import_time_of_start variable has been set. Update all imported
            # items accordingly.
            now = import_time_of_start.time
            diff = int(now / 86400)
            for i in self.imported_items:
                i.next_rep = i.next_rep - diff
                i.last_rep = i.last_rep - diff